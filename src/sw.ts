/**
 * Custom Service Worker - Background Sync for Mood Syncing
 *
 * This extends the Workbox-generated service worker to add
 * Background Sync API support for syncing pending moods.
 *
 * REAL Background Sync Implementation:
 * - Opens IndexedDB directly (no window context needed)
 * - Reads pending moods from IndexedDB
 * - Calls Supabase REST API via fetch (not JS client)
 * - Works even when app is completely closed
 *
 * Part of Hybrid Sync Solution:
 * - Immediate sync (App.tsx) - on mood creation
 * - Periodic sync (App.tsx) - while app is open
 * - Background Sync (here) - when app is closed or offline then online
 */

/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import {
  getPendingMoods,
  getAuthToken,
  markMoodSynced,
  type StoredMoodEntry,
} from './sw-db';

// Background Sync API types
interface SyncEvent extends ExtendableEvent {
  readonly tag: string;
  readonly lastChance: boolean;
}

// Service Worker type definitions
declare const self: ServiceWorkerGlobalScope & {
  __WB_MANIFEST: any[];
};

// Supabase configuration from environment variables
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_DEFAULT_KEY as string;

// Precache all static assets (generated by VitePWA)
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

/**
 * Background Sync Event Handler
 *
 * Triggers when:
 * 1. Browser regains connectivity after being offline
 * 2. Sync is manually triggered via registration.sync.register()
 *
 * This ACTUALLY syncs pending moods from IndexedDB to Supabase,
 * even when the app is completely closed.
 */
self.addEventListener(
  'sync',
  ((event: SyncEvent) => {
    if (event.tag === 'sync-pending-moods') {
      console.log('[ServiceWorker] Background Sync triggered:', event.tag);
      event.waitUntil(syncPendingMoods());
    }
  }) as EventListener
);

/**
 * Transform local mood format to Supabase REST API format
 *
 * Handles both single-mood (legacy) and multi-mood entries:
 * - mood_type: Always the primary mood (first in array or single mood)
 * - mood_types: Array of all selected moods (includes primary)
 */
function transformMoodForSupabase(
  mood: StoredMoodEntry,
  userId: string
): Record<string, unknown> {
  // Determine mood_types array: use stored moods array, or create single-element array
  const moodTypes = mood.moods && mood.moods.length > 0 ? mood.moods : [mood.mood];

  return {
    user_id: userId,
    mood_type: mood.mood,
    mood_types: moodTypes,
    note: mood.note || null,
    created_at: mood.timestamp instanceof Date
      ? mood.timestamp.toISOString()
      : new Date(mood.timestamp).toISOString(),
  };
}

/**
 * Sync pending moods from IndexedDB to Supabase
 *
 * This is the REAL background sync implementation:
 * 1. Opens IndexedDB directly (works without window)
 * 2. Gets pending moods
 * 3. Gets stored auth token
 * 4. Calls Supabase REST API with fetch
 * 5. Marks moods as synced on success
 */
async function syncPendingMoods(): Promise<void> {
  try {
    // 1. Get pending moods from IndexedDB
    const pendingMoods = await getPendingMoods();

    if (pendingMoods.length === 0) {
      console.log('[ServiceWorker] No pending moods to sync');
      return;
    }

    console.log(`[ServiceWorker] Found ${pendingMoods.length} pending moods to sync`);

    // 2. Get auth token from IndexedDB
    const authToken = await getAuthToken();

    if (!authToken) {
      console.log('[ServiceWorker] No auth token available - will retry on next sync');
      // Don't throw - let the sync retry mechanism handle this
      return;
    }

    // Check if token is expired (with 5 minute buffer)
    const now = Math.floor(Date.now() / 1000);
    if (authToken.expiresAt && authToken.expiresAt < now + 300) {
      console.log('[ServiceWorker] Auth token expired - will sync when app refreshes token');
      // Don't throw - let the app refresh the token on next open
      return;
    }

    // 3. Sync each mood to Supabase via REST API
    let successCount = 0;
    let failCount = 0;

    for (const mood of pendingMoods) {
      if (!mood.id) {
        console.error('[ServiceWorker] Mood missing local ID, skipping');
        failCount++;
        continue;
      }

      try {
        const supabaseMood = transformMoodForSupabase(mood, authToken.userId);

        // Call Supabase REST API directly
        const response = await fetch(`${SUPABASE_URL}/rest/v1/moods`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${authToken.accessToken}`,
            'Prefer': 'return=representation',
          },
          body: JSON.stringify(supabaseMood),
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error(
            `[ServiceWorker] Failed to sync mood ${mood.id}:`,
            response.status,
            errorText
          );
          failCount++;
          continue;
        }

        // Parse response to get Supabase ID
        const [created] = await response.json();

        if (!created?.id) {
          console.error('[ServiceWorker] No ID in Supabase response for mood', mood.id);
          failCount++;
          continue;
        }

        // 4. Mark as synced in IndexedDB
        await markMoodSynced(mood.id, created.id);
        successCount++;
        console.log(`[ServiceWorker] Synced mood ${mood.id} â†’ ${created.id}`);
      } catch (moodError) {
        console.error(`[ServiceWorker] Error syncing mood ${mood.id}:`, moodError);
        failCount++;
      }
    }

    console.log(
      `[ServiceWorker] Sync complete: ${successCount} succeeded, ${failCount} failed`
    );

    // 5. Notify open clients that sync completed
    const clients = await self.clients.matchAll({ type: 'window' });
    for (const client of clients) {
      client.postMessage({
        type: 'BACKGROUND_SYNC_COMPLETED',
        successCount,
        failCount,
      });
    }

    // If all failed, throw to trigger retry
    if (successCount === 0 && failCount > 0) {
      throw new Error(`All ${failCount} moods failed to sync`);
    }
  } catch (error) {
    console.error('[ServiceWorker] Background sync failed:', error);
    throw error; // Re-throw to trigger retry via Background Sync API
  }
}

/**
 * Message Handler
 *
 * Receives messages from the main app
 */
self.addEventListener(
  'message',
  ((event: ExtendableMessageEvent) => {
    if (event.data?.type === 'SKIP_WAITING') {
      self.skipWaiting();
    }
  }) as EventListener
);

// Log when service worker is activated
self.addEventListener(
  'activate',
  ((event: ExtendableEvent) => {
    console.log('[ServiceWorker] Activated - Background Sync ready');
    event.waitUntil(self.clients.claim());
  }) as EventListener
);
