<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>5</epicId>
    <storyId>4</storyId>
    <title>Add Unit Tests for Utilities and Services</title>
    <status>drafted</status>
    <generatedAt>2025-11-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/5-4-add-unit-tests-for-utilities-and-services.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>unit tests for critical utilities and services</iWant>
    <soThat>I can refactor confidently without breaking functionality</soThat>
    <tasks>
- Task 1: Install and Configure Vitest (AC: #1, #7)
- Task 2: Test Utility Functions - Date Helpers (AC: #2, #5)
- Task 3: Test Utility Functions - Message Rotation (AC: #2, #5)
- Task 4: Test Service Layer - BaseIndexedDBService (AC: #3, #5)
- Task 5: Test Service Layer - Specific Services (AC: #3, #5)
- Task 6: Test Zustand Store Slices (AC: #4, #5)
- Task 7: Verify Coverage Thresholds Met (AC: #5)
- Task 8: Optimize Test Performance (AC: #6)
- Task 9: Configure CI Coverage Enforcement (AC: #7)
- Task 10: Document Testing Approach (AC: #8)
    </tasks>
  </story>

  <acceptanceCriteria>
1. Set up Vitest for unit testing (fast, Vite-native)
2. Add tests for utility functions: date calculations, message rotation algorithm, validation helpers
3. Add tests for service layer: BaseIndexedDBService methods (use fake-indexeddb)
4. Add tests for Zustand store slices: state updates, selectors, actions
5. Achieve 80%+ code coverage for utilities and services
6. Tests run in under 5 seconds total (fast feedback loop)
7. Configure test scripts: npm run test:unit, npm run test:unit:watch, npm run test:unit:coverage
8. Document testing approach in tests/README.md
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-5.md</path>
        <title>Epic 5 Technical Specification: Code Quality &amp; Performance</title>
        <section>Story 5.4: Unit Test Setup</section>
        <snippet>Install Vitest with fake-indexeddb. Test utilities (dateHelpers, messageRotation), BaseIndexedDBService CRUD operations, and store slices. Target: 80%+ coverage, &lt;5 second execution time.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-5.md</path>
        <title>Test Strategy Summary</title>
        <section>Test Pyramid Approach</section>
        <snippet>Unit tests with Vitest form foundation of test pyramid. Focus: utilities (90%+ coverage), services (85%+ coverage), stores (75%+ coverage). E2E tests from Epic 2 validate integration.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Documentation</title>
        <section>State Management - Zustand Store Architecture</section>
        <snippet>Single store pattern with persist middleware. State includes: settings, messages, messageHistory, currentMessage, moods, photos. 15 actions for CRUD operations.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Data Architecture</title>
        <section>IndexedDB Schema</section>
        <snippet>Database: my-love-db. Stores: photos (by-date index), messages (by-category, by-date indexes). Auto-increment primary keys.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>src/utils/dateHelpers.ts</path>
        <kind>utility</kind>
        <symbol>isToday, isSameDay, formatDateISO, getDaysUntil, getDaysSince, addDays, getNextAnniversary, formatCountdown</symbol>
        <lines>1-152</lines>
        <reason>Core date utilities requiring comprehensive unit tests. Functions handle date comparisons, formatting, and duration calculations. Critical for relationship duration features.</reason>
      </artifact>
      <artifact>
        <path>src/utils/messageRotation.ts</path>
        <kind>utility</kind>
        <symbol>formatDate, hashDateString, getDailyMessage, getMessageForDate, getAvailableHistoryDays, getDaysSinceStart, formatRelationshipDuration</symbol>
        <lines>1-195</lines>
        <reason>Message rotation algorithm using deterministic date hashing. Critical logic requiring tests for: same date = same message, wrapping behavior, history tracking.</reason>
      </artifact>
      <artifact>
        <path>src/services/customMessageService.ts</path>
        <kind>service</kind>
        <symbol>CustomMessageService</symbol>
        <lines>16-299</lines>
        <reason>IndexedDB service for custom messages. Tests needed for: CRUD operations, filtering, export/import, duplicate detection. Uses singleton pattern with init guard.</reason>
      </artifact>
      <artifact>
        <path>src/services/photoStorageService.ts</path>
        <kind>service</kind>
        <symbol>PhotoStorageService</symbol>
        <lines>20-322</lines>
        <reason>Photo storage service with pagination. Tests needed for: CRUD, pagination (getPage), storage quota estimation, by-date index sorting. Singleton with v2 migration.</reason>
      </artifact>
      <artifact>
        <path>src/stores/useAppStore.ts</path>
        <kind>store</kind>
        <symbol>AppState, initializeApp, loadMessages, toggleFavorite, updateCurrentMessage, loadCustomMessages, loadPhotos</symbol>
        <lines>1-100</lines>
        <reason>Zustand store with persist middleware. Tests needed for: state updates, action correctness, selector behavior. Note: Story 5.1 may refactor into slices.</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <vitest>^2.0.0 - Unit testing framework (new dependency)</vitest>
        <vitest-ui>^2.0.0 - Interactive test UI (new dependency)</vitest-ui>
        <fake-indexeddb>^6.0.0 - IndexedDB mocking for tests (new dependency)</fake-indexeddb>
        <zustand>5.0.8 - State management (existing)</zustand>
        <idb>8.0.3 - IndexedDB wrapper (existing)</idb>
        <zod>3.25.76 - Runtime validation (existing, used for validation tests)</zod>
        <playwright>1.56.1 - E2E testing framework (existing, separate from unit tests)</playwright>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
- Use Vitest (not Jest) for Vite-native testing without transpilation overhead
- Use fake-indexeddb for IndexedDB mocking to avoid real database dependencies
- Co-locate tests with source files: dateHelpers.test.ts next to dateHelpers.ts
- Test file pattern: *.test.ts or *.spec.ts (Vitest auto-discovers)
- Use v8 coverage provider for speed (&lt;1 second coverage generation)
- Use jsdom test environment for DOM API compatibility (Zustand uses localStorage)
- All tests must pass consistently (no flaky tests allowed)
- Tests must run in parallel (Vitest default) for &lt;5 second total execution
- Maintain API compatibility: tests should not require code changes to pass
- Use vi.useFakeTimers() for deterministic date testing (message rotation)
- Use vi.mock() to isolate service layer from IndexedDB in store tests
- Follow Arrange-Act-Assert pattern for test structure
- Test naming: describe(function/class) -&gt; it(behavior in plain English)
- Minimum coverage thresholds: utilities 90%, services 85%, stores 75%, overall 80%
  </constraints>

  <interfaces>
    <interface>
      <name>dateHelpers utility functions</name>
      <kind>Pure functions</kind>
      <signature>
isToday(date: Date): boolean
isSameDay(date1: Date, date2: Date): boolean
formatDateISO(date: Date): string
getDaysUntil(targetDate: Date): number
getDaysSince(pastDate: Date): number
addDays(date: Date, days: number): Date
getNextAnniversary(anniversaryDate: string): Date
formatCountdown(days: number): string
      </signature>
      <path>src/utils/dateHelpers.ts</path>
    </interface>

    <interface>
      <name>messageRotation algorithm</name>
      <kind>Pure functions with deterministic hashing</kind>
      <signature>
formatDate(date: Date): string
hashDateString(dateString: string): number
getDailyMessage(allMessages: Message[], date?: Date): Message
getMessageForDate(allMessages: Message[], targetDate: Date): Message
getAvailableHistoryDays(messageHistory: MessageHistory, settings: Settings): number
getDaysSinceStart(startDate: Date, targetDate?: Date): number
formatRelationshipDuration(startDate: Date, targetDate?: Date): string
      </signature>
      <path>src/utils/messageRotation.ts</path>
    </interface>

    <interface>
      <name>CustomMessageService CRUD API</name>
      <kind>IndexedDB service class</kind>
      <signature>
class CustomMessageService {
  async init(): Promise&lt;void&gt;
  async create(input: CreateMessageInput): Promise&lt;Message&gt;
  async update(input: UpdateMessageInput): Promise&lt;void&gt;
  async delete(messageId: number): Promise&lt;void&gt;
  async getAll(filter?: MessageFilter): Promise&lt;Message[]&gt;
  async getById(messageId: number): Promise&lt;Message | null&gt;
  async getActiveCustomMessages(): Promise&lt;Message[]&gt;
  async exportMessages(): Promise&lt;CustomMessagesExport&gt;
  async importMessages(exportData: CustomMessagesExport): Promise&lt;{imported: number, skipped: number}&gt;
}
      </signature>
      <path>src/services/customMessageService.ts</path>
    </interface>

    <interface>
      <name>PhotoStorageService CRUD + Pagination API</name>
      <kind>IndexedDB service class</kind>
      <signature>
class PhotoStorageService {
  async init(): Promise&lt;void&gt;
  async create(photo: Omit&lt;Photo, 'id'&gt;): Promise&lt;Photo&gt;
  async getAll(): Promise&lt;Photo[]&gt;
  async getPage(offset: number, limit: number): Promise&lt;Photo[]&gt;
  async getById(photoId: number): Promise&lt;Photo | null&gt;
  async update(photoId: number, updates: Partial&lt;Photo&gt;): Promise&lt;void&gt;
  async delete(photoId: number): Promise&lt;void&gt;
  async getStorageSize(): Promise&lt;number&gt;
  async estimateQuotaRemaining(): Promise&lt;{used, quota, remaining, percentUsed}&gt;
}
      </signature>
      <path>src/services/photoStorageService.ts</path>
    </interface>

    <interface>
      <name>Zustand Store Actions (subset for testing)</name>
      <kind>State management store</kind>
      <signature>
interface AppState {
  // State
  messages: Message[]
  currentMessage: Message | null
  messageHistory: MessageHistory
  customMessages: CustomMessage[]
  photos: Photo[]

  // Actions to test
  loadMessages(): Promise&lt;void&gt;
  toggleFavorite(messageId: number): Promise&lt;void&gt;
  updateCurrentMessage(): void
  loadCustomMessages(): Promise&lt;void&gt;
  loadPhotos(): Promise&lt;void&gt;
  createCustomMessage(input: CreateMessageInput): Promise&lt;void&gt;
  updateCustomMessage(input: UpdateMessageInput): Promise&lt;void&gt;
  deleteCustomMessage(id: number): Promise&lt;void&gt;
}
      </signature>
      <path>src/stores/useAppStore.ts</path>
    </interface>

    <interface>
      <name>BaseIndexedDBService (Story 5.3 dependency)</name>
      <kind>Abstract generic base class</kind>
      <signature>
abstract class BaseIndexedDBService&lt;T extends { id?: number }&gt; {
  constructor(dbName: string, storeName: string, version: number)
  abstract getAll(): Promise&lt;T[]&gt;
  abstract get(id: number): Promise&lt;T | undefined&gt;
  abstract add(item: Omit&lt;T, 'id'&gt;): Promise&lt;number&gt;
  abstract update(id: number, updates: Partial&lt;T&gt;): Promise&lt;void&gt;
  abstract delete(id: number): Promise&lt;void&gt;
  abstract clear(): Promise&lt;void&gt;
  getPage(page: number, pageSize: number): Promise&lt;T[]&gt;
}
      </signature>
      <path>src/services/BaseIndexedDBService.ts (from Story 5.3)</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Unit testing framework: Vitest v2.0+ with fake-indexeddb for IndexedDB mocking. Test environment: jsdom (for localStorage compatibility). Coverage provider: v8 (native V8, faster than Istanbul). Coverage thresholds enforced in vitest.config.ts: 80% overall, 90% utilities, 85% services, 75% stores. Parallel execution enabled by default. All tests must be deterministic (no random failures). Use vi.useFakeTimers() for date-dependent tests. Use vi.mock() to isolate services from IndexedDB in store tests. Follow Arrange-Act-Assert pattern. Test files co-located with source (dateHelpers.test.ts next to dateHelpers.ts).
    </standards>

    <locations>
- src/**/*.test.ts - Co-located test files (Vitest auto-discovers)
- tests/utils/testHelpers.ts - Shared test utilities (factory functions)
- tests/README.md - Testing documentation and guidelines
- coverage/ - Generated coverage reports (HTML + lcov)
- vitest.config.ts - Vitest configuration with coverage thresholds
    </locations>

    <ideas>
      <idea ac="1,7">
- Install vitest, @vitest/ui, fake-indexeddb
- Create vitest.config.ts with jsdom environment, v8 coverage, 80% thresholds
- Add test scripts to package.json: test:unit, test:unit:watch, test:unit:coverage
- Verify installation: npm run test:unit (should find 0 tests initially)
      </idea>

      <idea ac="2,5">
- Test dateHelpers.ts functions:
  * isToday/isSameDay: edge cases (midnight boundary, DST transitions)
  * formatDateISO: ISO 8601 compliance
  * getDaysUntil/getDaysSince: leap years, same-day, negative values
  * getNextAnniversary: year wrapping, leap day handling (Feb 29)
  * formatCountdown: 0 days, 1 day, weeks, months, years boundaries
- Use vi.useFakeTimers() to control current date for deterministic tests
- Target: 90%+ coverage for pure date utility functions
      </idea>

      <idea ac="2,5">
- Test messageRotation.ts algorithm:
  * hashDateString: determinism (same input = same output always)
  * getDailyMessage: same date returns same message across runs
  * getDailyMessage: different dates return different messages
  * getDailyMessage: wrapping behavior with 365+ messages
  * getAvailableHistoryDays: respects maxHistoryDays and relationship duration
  * formatRelationshipDuration: years/months breakdown accuracy
- Mock dates with vi.setSystemTime() for controlled testing
- Test edge cases: empty message pool, single message, future dates
- Target: 90%+ coverage for rotation algorithm
      </idea>

      <idea ac="3,5">
- Test CustomMessageService (if Story 5.3 not complete, test without base class):
  * CRUD operations: create, getAll, getById, update, delete
  * Filtering: by category, by active status, by search term, by tags
  * Export/import: JSON serialization, duplicate detection
  * Error handling: missing IDs, quota exceeded, transaction errors
- Use fake-indexeddb/auto to polyfill IndexedDB
- Reset DB between tests: beforeEach(() => indexedDB = new IDBFactory())
- Target: 80%+ coverage for service-specific logic
      </idea>

      <idea ac="3,5">
- Test PhotoStorageService:
  * CRUD operations: create, getAll, getById, update, delete
  * Pagination: getPage with offset/limit, boundary cases (empty, partial pages)
  * Storage quota: getStorageSize, estimateQuotaRemaining
  * Index usage: by-date sorting (newest first)
- Mock navigator.storage.estimate() for quota tests
- Test v1 to v2 migration if possible
- Target: 80%+ coverage
      </idea>

      <idea ac="3,5">
- Test BaseIndexedDBService (Story 5.3 dependency):
  * Create concrete test implementation: class TestService extends BaseIndexedDBService&lt;TestItem&gt;
  * Test all CRUD methods: add, get, getAll, update, delete, clear
  * Test pagination: getPage with various page/size combinations
  * Test error handling: quota exceeded, transaction errors, missing IDs
  * Test init guard: concurrent init calls, idempotency
- Target: 85%+ coverage for base class
      </idea>

      <idea ac="4,5">
- Test Zustand store slices (or monolithic store if Story 5.1 not complete):
  * loadMessages: messages loaded from IndexedDB
  * toggleFavorite: state updated, persisted to IndexedDB
  * updateCurrentMessage: correct message calculated for current date
  * loadCustomMessages: custom messages loaded and merged
  * createCustomMessage/updateCustomMessage/deleteCustomMessage: state updated
- Mock service layer with vi.mock('@/services/customMessageService')
- Test selectors if using memoization
- Target: 75%+ coverage for store logic
      </idea>

      <idea ac="5">
- Run npm run test:unit:coverage
- Review coverage report in coverage/index.html
- Verify thresholds: dateHelpers ≥90%, messageRotation ≥90%, services ≥80-85%, stores ≥75%, overall ≥80%
- Document any intentionally untested code (error logging, dev-only code)
      </idea>

      <idea ac="6">
- Measure execution time: npm run test:unit (target &lt;5 seconds)
- Optimizations if needed: parallel execution (default), fake timers, mock IndexedDB, reduce setup/teardown
- Run 3 times to verify consistent performance
- Document baseline in tests/README.md
      </idea>

      <idea ac="7">
- Update .github/workflows/playwright.yml or create unit-tests.yml
- Add unit test job before E2E tests
- Upload coverage reports as artifacts
- Fail workflow if coverage &lt;80%
- Test CI on feature branch
      </idea>

      <idea ac="8">
- Create tests/README.md with:
  * Test pyramid explanation (E2E vs Unit)
  * How to run tests locally (scripts)
  * Coverage thresholds and rationale
  * Mocking patterns (fake-indexeddb, vi.mock)
  * Testing guidelines (AAA, naming conventions)
  * Example tests for utilities, services, stores
      </idea>
    </ideas>
  </tests>
</story-context>
