<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>5</epicId>
    <storyId>2</storyId>
    <title>Implement Photo Pagination with Lazy Loading</title>
    <status>drafted</status>
    <generatedAt>2025-11-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/5-2-implement-photo-pagination-with-lazy-loading.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>the photo gallery to load efficiently without loading all photos into memory</iWant>
    <soThat>the app remains responsive even with hundreds of photos</soThat>
    <tasks>
- Task 1: Verify Existing Implementation (AC: 1, 2, 3, 4)
  - Subtask 1.1: Review current PhotoGallery.tsx implementation (already uses getPage() with PHOTOS_PER_PAGE=20)
  - Subtask 1.2: Verify pagination state management (currentOffset, hasMore, isLoading, isLoadingMore)
  - Subtask 1.3: Test infinite scroll with Intersection Observer (observerTarget ref)
  - Subtask 1.4: Confirm loadMorePhotos callback functionality
  - Subtask 1.5: Review empty state and initial loading indicators

- Task 2: Enhance Loading States (AC: 4)
  - Subtask 2.1: Add skeleton loader component for grid items during initial load
  - Subtask 2.2: Implement shimmer animation for skeleton placeholders
  - Subtask 2.3: Replace simple spinner with skeleton grid (3x3 placeholder grid)
  - Subtask 2.4: Add "Loading more photos..." indicator at bottom during pagination
  - Subtask 2.5: Ensure smooth transition from skeleton to actual photos (fade-in animation)

- Task 3: Optimize Memory Management (AC: 5)
  - Subtask 3.1: Profile current memory usage with Chrome DevTools Memory tab
  - Subtask 3.2: Test with 100+ photos dataset (generate mock photos if needed)
  - Subtask 3.3: Verify memory stays under 100MB with 500+ photos
  - Subtask 3.4: Ensure pagination prevents loading all photos into memory simultaneously
  - Subtask 3.5: Document memory benchmarks before/after in completion notes

- Task 4: Improve Infinite Scroll UX (AC: 3)
  - Subtask 4.1: Verify Intersection Observer threshold (currently triggers at SCROLL_THRESHOLD=200px)
  - Subtask 4.2: Test scroll performance on mobile and desktop
  - Subtask 4.3: Add "No more photos" indicator when hasMore=false
  - Subtask 4.4: Prevent multiple simultaneous load requests (isLoadingMore guard)
  - Subtask 4.5: Add error boundary for pagination failures (graceful degradation)

- Task 5: Add E2E Tests for Pagination (AC: 6)
  - Subtask 5.1: Create test fixture with 50+ photos for pagination testing
  - Subtask 5.2: Test initial load shows first 20 photos
  - Subtask 5.3: Test infinite scroll triggers when scrolling to bottom
  - Subtask 5.4: Test "load more" loads next page correctly
  - Subtask 5.5: Test "no more photos" state when all photos loaded
  - Subtask 5.6: Test empty gallery state (0 photos)
  - Subtask 5.7: Test pagination after photo upload (refresh behavior)

- Task 6: Optimize IndexedDB Queries (AC: 1)
  - Subtask 6.1: Review photoStorageService.getPage() implementation
  - Subtask 6.2: Verify efficient cursor-based pagination (currently slices after getAllFromIndex)
  - Subtask 6.3: Consider implementing cursor pagination for better performance with large datasets
  - Subtask 6.4: Benchmark query performance with 100, 500, 1000 photos
  - Subtask 6.5: Document pagination strategy in technical-decisions.md

- Task 7: Handle Edge Cases (AC: 2, 3)
  - Subtask 7.1: Test pagination with exactly 20 photos (1 page, no "load more")
  - Subtask 7.2: Test pagination with 21 photos (1 page + 1 photo on second page)
  - Subtask 7.3: Test pagination with 0 photos (empty state)
  - Subtask 7.4: Test refresh after photo deletion (offset adjustment)
  - Subtask 7.5: Test concurrent pagination requests (debouncing)

- Task 8: Update Documentation (AC: 1-6)
  - Subtask 8.1: Document pagination implementation in technical-decisions.md
  - Subtask 8.2: Update PhotoGallery component docstring with pagination details
  - Subtask 8.3: Document memory optimization benchmarks
  - Subtask 8.4: Add inline comments for Intersection Observer setup
  - Subtask 8.5: Document edge cases and fallback behaviors
    </tasks>
  </story>

  <acceptanceCriteria>
1. PhotoGallery uses `getPage()` method: Update PhotoGallery component to use existing `getPage(page, pageSize)` method from photoStorageService
2. 20 photos per page displayed: Implement pagination with 20 photos per page (configurable constant)
3. "Load More" button or infinite scroll implemented: Add UI mechanism for loading additional pages
4. Loading states with skeleton loaders: Display loading indicators during initial load and "load more" operations
5. Memory usage tested with 100+ photos: Verify memory optimization with large photo collections
6. E2E tests cover pagination scenarios: Add or update tests to validate pagination behavior
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- Epic-level documentation -->
      <artifact>
        <path>docs/epics.md</path>
        <title>Epic 5: Code Quality & Performance Improvements</title>
        <section>Story 5.2: Implement Photo Pagination with Lazy Loading</section>
        <snippet>Update PhotoGallery component to use existing getPage() pagination method. Implement virtual scrolling or progressive loading (load 20 photos per page). Add "Load More" button or infinite scroll behavior. Memory usage stays constant regardless of total photo count. IndexedDB queries optimized (use cursor pagination, not loading all then slicing).</snippet>
      </artifact>

      <!-- Architecture documentation -->
      <artifact>
        <path>docs/architecture.md</path>
        <title>Data Architecture - IndexedDB Schema</title>
        <section>photos object store</section>
        <snippet>Store photos with metadata (id, file blob, caption, tags, uploadDate). Index by-date enables sorted retrieval for pagination. Auto-increment primary key.</snippet>
      </artifact>

      <artifact>
        <path>docs/architecture.md</path>
        <title>Component Overview - Planned Components</title>
        <section>PhotoMemory</section>
        <snippet>Photo gallery with upload, caption, tag photos; grid view with lazy loading; lightbox carousel.</snippet>
      </artifact>

      <!-- Technical decisions -->
      <artifact>
        <path>docs/technical-decisions.md</path>
        <title>Client-Side Architecture Maintained</title>
        <section>Storage Layer</section>
        <snippet>IndexedDB for large data (photos, message library). Service Worker with Workbox for offline caching and PWA functionality.</snippet>
      </artifact>
    </docs>

    <code>
      <!-- Core implementation files -->
      <artifact>
        <path>src/components/PhotoGallery/PhotoGallery.tsx</path>
        <kind>component</kind>
        <symbol>PhotoGallery</symbol>
        <lines>1-250</lines>
        <reason>Main component implementing pagination. Already includes PHOTOS_PER_PAGE=20, Intersection Observer for infinite scroll, pagination state (currentOffset, hasMore, isLoading, isLoadingMore). Need to add skeleton loaders to replace simple spinner.</reason>
      </artifact>

      <artifact>
        <path>src/services/photoStorageService.ts</path>
        <kind>service</kind>
        <symbol>PhotoStorageService.getPage</symbol>
        <lines>158-179</lines>
        <reason>Pagination method used by PhotoGallery. Currently loads all photos then slices (getAllFromIndex then slice). Works for &lt;100 photos but inefficient with 500+. Consider cursor-based optimization.</reason>
      </artifact>

      <artifact>
        <path>src/components/PhotoGallery/PhotoGridItem.tsx</path>
        <kind>component</kind>
        <symbol>PhotoGridItem</symbol>
        <lines>1-50</lines>
        <reason>Grid item component showing individual photos. Skeleton loader should match this visual structure (aspect ratio, rounded corners).</reason>
      </artifact>

      <!-- Related store slices -->
      <artifact>
        <path>src/store/useAppStore.ts</path>
        <kind>store</kind>
        <symbol>useAppStore</symbol>
        <lines>1-1268</lines>
        <reason>Zustand store (to be split in Story 5.1). PhotoGallery maintains local pagination state, watches store photos array for upload detection.</reason>
      </artifact>

      <!-- Testing infrastructure -->
      <artifact>
        <path>tests/e2e/photo-gallery.spec.ts</path>
        <kind>test</kind>
        <symbol>photo-gallery tests</symbol>
        <lines>1-100</lines>
        <reason>Existing E2E tests for photo gallery. Need to add pagination-specific scenarios: initial load (20 photos), infinite scroll, edge cases, empty state.</reason>
      </artifact>

      <artifact>
        <path>tests/support/helpers/pwaHelpers.ts</path>
        <kind>test-helper</kind>
        <symbol>PWA test helpers</symbol>
        <lines>1-50</lines>
        <reason>Playwright helpers for IndexedDB operations. Use for seeding test photos (50+ photos for pagination testing).</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <framer-motion>^12.23.24</framer-motion>
        <idb>^8.0.3</idb>
        <lucide-react>^0.548.0</lucide-react>
        <react>^19.1.1</react>
        <zod>^3.25.76</zod>
        <zustand>^5.0.8</zustand>
      </node>
      <devDependencies>
        <playwright-test>^1.56.1</playwright-test>
        <tailwindcss>^3.4.18</tailwindcss>
      </devDependencies>
    </dependencies>
  </artifacts>

  <constraints>
- Pagination state remains local to PhotoGallery component (not in Zustand store) - UI concern, not domain state
- photoStorageService.getPage() provides data layer abstraction - maintain existing API contract
- PhotoGallery manages UI state (currentOffset, hasMore, isLoading, isLoadingMore), service manages data fetching
- Store's photos array remains as full dataset cache for PhotoCarousel compatibility
- Skeleton loaders must be built with Tailwind CSS and Framer Motion (no new dependencies)
- Use CSS shimmer animation for better performance (not Framer Motion opacity pulse for 9+ skeleton items)
- Maintain current photo ordering: newest first (by-date index reversed)
- PHOTOS_PER_PAGE constant set to 20 (configurable for easy adjustment)
- Memory usage target: &lt;50MB with 100 photos, &lt;100MB with 500 photos
- Scroll threshold: 200px from bottom triggers load more (SCROLL_THRESHOLD constant)
- Stick with slice-based pagination for MVP (defer cursor optimization until 500+ photos becomes real use case)
  </constraints>

  <interfaces>
    <!-- PhotoStorageService API -->
    <interface>
      <name>PhotoStorageService.getPage</name>
      <kind>method</kind>
      <signature>async getPage(offset: number = 0, limit: number = 20): Promise&lt;Photo[]&gt;</signature>
      <path>src/services/photoStorageService.ts</path>
    </interface>

    <!-- Photo type definition -->
    <interface>
      <name>Photo</name>
      <kind>interface</kind>
      <signature>interface Photo { id?: number; file: Blob; caption: string; tags: string[]; uploadDate: Date; }</signature>
      <path>src/types/photo.ts</path>
    </interface>

    <!-- PhotoGallery props -->
    <interface>
      <name>PhotoGalleryProps</name>
      <kind>interface</kind>
      <signature>interface PhotoGalleryProps { photos: Photo[]; onPhotoClick: (photo: Photo) =&gt; void; }</signature>
      <path>src/components/PhotoGallery/PhotoGallery.tsx</path>
    </interface>

    <!-- Intersection Observer for infinite scroll -->
    <interface>
      <name>IntersectionObserver</name>
      <kind>browser-api</kind>
      <signature>new IntersectionObserver(callback: IntersectionObserverCallback, options?: IntersectionObserverInit)</signature>
      <path>Web API</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Testing uses Playwright for E2E tests with PWA-specific helpers for IndexedDB operations. Tests located in tests/e2e/ directory. Existing helpers in tests/support/helpers/pwaHelpers.ts provide clearIndexedDB, waitForServiceWorker utilities. Test framework uses data-testid attributes for stable selectors. Auto-start preview server configured via playwright.config.ts. Target: all tests pass in Chromium, Firefox, WebKit under 5 minutes total.
    </standards>

    <locations>
tests/e2e/photo-pagination.spec.ts (new file for pagination-specific scenarios)
tests/e2e/photo-gallery.spec.ts (existing, may need updates)
tests/support/fixtures/ (for 50+ photo test fixtures)
    </locations>

    <ideas>
<!-- AC-1: PhotoGallery uses getPage() method -->
- Unit test: photoStorageService.getPage(0, 20) returns first 20 photos sorted newest first
- Unit test: photoStorageService.getPage(20, 20) returns second page (photos 21-40)
- E2E test: PhotoGallery calls getPage() on initial render (verify via network/console logs)

<!-- AC-2: 20 photos per page displayed -->
- E2E test: Given 50 photos, initial load shows exactly 20 photos in grid
- E2E test: PHOTOS_PER_PAGE constant can be changed to 10, grid shows 10 photos

<!-- AC-3: Infinite scroll implemented -->
- E2E test: Scroll to bottom (Intersection Observer target visible) triggers loadMorePhotos
- E2E test: After scroll load, grid shows 40 photos total (20 initial + 20 loaded)
- E2E test: With 25 photos total, scroll loads last 5 photos, hasMore becomes false
- E2E test: Keyboard navigation triggers infinite scroll (accessibility)

<!-- AC-4: Loading states with skeleton loaders -->
- E2E test: Initial load shows 3x3 skeleton grid with shimmer animation
- E2E test: During "load more", bottom loading indicator visible ("Loading more photos...")
- E2E test: Skeleton loaders replaced with actual photos after load completes
- Visual test: Screenshot skeleton loader matches PhotoGridItem aspect ratio

<!-- AC-5: Memory usage tested with 100+ photos -->
- Manual test: Chrome DevTools Memory profiling with 100 photos, verify &lt;50MB
- Manual test: Memory profiling with 500 photos, verify &lt;100MB
- Manual test: Heap snapshot confirms old pages garbage collected (no memory leak)
- Benchmark: Document initial load time (first 20 photos) &lt;500ms target

<!-- AC-6: E2E tests cover pagination scenarios -->
- E2E test: Empty gallery (0 photos) shows empty state, no pagination
- E2E test: Exactly 20 photos shows all photos, hasMore=false, no infinite scroll trigger
- E2E test: 21 photos shows 20 initially, scroll loads 1 more, "no more photos" indicator
- E2E test: Upload new photo, gallery refreshes, new photo appears at top
- E2E test: Delete photo during pagination, offset adjusts correctly
- E2E test: Concurrent scroll requests prevented (isLoadingMore guard works)
    </ideas>
  </tests>
</story-context>
